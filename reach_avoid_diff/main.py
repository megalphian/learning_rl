# Generated by Gemini. Edited by Megnath Ramesh
# Reach and avoid task simulation using mujoco

import mujoco
import mujoco.viewer
import numpy as np

# --- Configuration ---
XML_PATH = 'reach_avoid_env.xml'
SIM_DURATION = 20  # seconds
TARGET_POSITION = np.array([0.3, 0.3, 0.3]) # From XML, can be overridden here
OBSTACLE_POSITION = np.array([-0.2, -0.2, 0.4]) # From XML, can be overridden here

# Control gains
KP_REACH = 50.0  # Proportional gain for reaching the target
KD_REACH = 5.0   # Derivative gain for reaching the target
KP_AVOID = 100.0 # Proportional gain for avoiding the obstacle
DANGER_RADIUS = 0.2 # Radius around obstacle where avoidance activates

# --- Main Program ---
def main():
    # Load the MuJoCo model
    try:
        model = mujoco.MjModel.from_xml_path(XML_PATH)
    except Exception as e:
        print(f"Error loading MuJoCo model from {XML_PATH}: {e}")
        print("Please ensure 'reach_avoid_env.xml' is in the same directory.")
        return

    data = mujoco.MjData(model)

    # Setup the viewer
    with mujoco.viewer.launch_passive(model, data) as viewer:
        start_time = data.time

        while viewer.is_running():

            # --- Get current positions ---
            current_end_effector_pos = data.site('end_effector').xpos
            current_obstacle_pos = data.body('obstacle').xpos
            current_target_pos = data.body('target').xpos

            # --- Calculate Reach Task Error ---
            error_to_target = current_target_pos - current_end_effector_pos

            # Get current joint velocities
            joint_velocities = data.qvel[:model.nv] # Get velocities for all movable joints

            # Compute desired torques for reaching
            # This is a very basic PD control on Cartesian error,
            # which is then applied to joint torques.
            # In a real scenario, you'd use Jacobian Transpose or inverse kinematics
            # to map Cartesian forces/velocities to joint torques.
            # For this simple 2D-like arm, we'll make a simplifying assumption.
            # We'll apply torques proportional to the error and oppose velocity.
            # This is a highly simplified approach and won't work perfectly for 3D arms,
            # but serves for demonstration.

            # Simplified approach: Use end-effector position to influence joint torques
            # This part is a simplification. A proper solution would involve Jacobian.
            # For a 2-DOF arm moving in a plane, this might be somewhat effective.
            # Joint 1 (yaw) influences X, Y. Joint 2 (pitch) influences Z and distance from base.

            # Target control: try to move end-effector towards target
            # This is a very rough mapping for illustration.
            # For a 2-DOF arm, joint 1 controls yaw, joint 2 controls pitch/height.
            # We'll try to relate X/Y error to joint 1 and Z error to joint 2.
            # This is NOT a proper Jacobian-based control.
            # It's an intuitive mapping for simple visual effect.
            # control_reach_x = KP_REACH * error_to_target[0] - KD_REACH * joint_velocities[0] # Roughly X/Y for joint1
            # control_reach_z = KP_REACH * error_to_target[2] - KD_REACH * joint_velocities[1] # Roughly Z for joint2
            # # Combine into control signal for each joint
            # reach_torques = np.array([control_reach_x, control_reach_z])


            # --- Calculate Avoid Task ---
            vec_ee_to_obstacle = current_end_effector_pos - current_obstacle_pos
            distance_to_obstacle = np.linalg.norm(vec_ee_to_obstacle)

            avoid_torques = np.zeros(model.nu) # nu is number of actuators

            if distance_to_obstacle < DANGER_RADIUS:
                # Calculate repulsive force direction
                if distance_to_obstacle > 1e-6: # Avoid division by zero
                    avoid_direction = vec_ee_to_obstacle / distance_to_obstacle
                else: # If exactly at the obstacle, push in arbitrary direction
                    avoid_direction = np.array([1.0, 0.0, 0.0]) # Arbitrary

                # Calculate magnitude of repulsive force (stronger closer to obstacle)
                avoid_magnitude = KP_AVOID * (1 - (distance_to_obstacle / DANGER_RADIUS))**2

                # Apply repulsive "force" as torques (simplified mapping)
                # Similar simplification as reach control. Push away from obstacle.
                avoid_torques[0] += avoid_magnitude * avoid_direction[0] # Roughly X/Y for joint1
                avoid_torques[1] += avoid_magnitude * avoid_direction[2] # Roughly Z for joint2


            # --- Combine Control Efforts ---
            # Sum the reach and avoid torques. Avoidance takes priority when close.
            # data.ctrl = avoid_torques

            # --- Step the simulation ---
            mujoco.mj_step(model, data)

            # Update the viewer
            viewer.sync()

            # Optional: Print info for debugging
            # print(f"Time: {data.time:.2f}s, EE Pos: {current_end_effector_pos}, Dist to Obstacle: {distance_to_obstacle:.3f}")

        print("Simulation finished.")

if __name__ == "__main__":
    main()